<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>位运算</title>
      <link href="/Learning-Records/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/Learning-Records/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-2917-找出数组中的-K-or-值"><a href="#leetcode-2917-找出数组中的-K-or-值" class="headerlink" title="leetcode_2917. 找出数组中的 K-or 值"></a>leetcode_2917. 找出数组中的 K-or 值</h3><p>简单的进行位运算，记录每一个位置上1出现的次数，使用与运算。</p><pre><code class="java"> public static int findKOr(int[] nums, int k) &#123;        //使用哈希表来记录每一位上出现的1的个数        Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();        for(int x:nums)&#123;            for(int i=0;i&lt;31;i++)&#123;                int num=1;                num&lt;&lt;=i;                if((num&amp;x)==num)&#123; //这个位置上为1                  map.put(i,map.getOrDefault(i,0)+1);                &#125;            &#125;        &#125;        int ans=0;        for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;            int count= entry.getValue();            int key = entry.getKey();            if(count&gt;=k) ans+=(1&lt;&lt;key);        &#125;        return ans;    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/Learning-Records/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/Learning-Records/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-275-H-指数-II"><a href="#leetcode-275-H-指数-II" class="headerlink" title="leetcode_275. H 指数 II"></a>leetcode_275. H 指数 II</h3><p>二分查找的经典应用：找到第一个符合要求的位置</p><pre><code class="java">    public static int hIndex(int[] citations) &#123;        int n=citations.length;        if(n==1) return citations[0]&gt;0?1:0;        int right= citations.length;        int left=0;        while (left&lt;right)&#123;//right:第一个满足要求的位置            int mid=(left+right)/2;            if(citations[mid]&gt;=(n-mid))&#123;//(n-mid+1)此位置后面的书                right=mid;            &#125;else &#123;                left=mid+1;            &#125;        &#125;        return n-right;    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="/Learning-Records/%E5%9B%9E%E6%BA%AF/"/>
      <url>/Learning-Records/%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-2305-公平分发饼干"><a href="#leetcode-2305-公平分发饼干" class="headerlink" title="leetcode_2305. 公平分发饼干"></a>leetcode_2305. 公平分发饼干</h3><p>回溯类的题目，直接回溯求解，使用数组记录每个小朋友的状况，将每种可能的答案都记录下来。最需要注意的地方就是，第一个饼干给谁都是一样的，每个树的构造都是相同的，所以当遇到再次分第一个饼干的归属的时候直接剪枝。可以多做做回溯类的题目。</p><pre><code class="java">  int ans = Integer.MAX_VALUE;    int k;    int[] cookies;    int n;    public int distributeCookies(int[] cookies, int k) &#123;        this.cookies = cookies;        n = cookies.length;        this.k = k;        //我们在分配第一个饼干的时候，无论分配给哪个小孩，我们开启的回溯树都是一模一样的        backtrack(new int[k], n - 1);        return ans;    &#125;    public void backtrack(int[] bucket, int start) &#123;        if (start &lt; 0) &#123;            //说明饼干分完了            int curans = Integer.MIN_VALUE;            for (int count : bucket) &#123;                curans = Math.max(curans, count);            &#125;            ans = Math.min(ans,curans);            return;        &#125;        //剪枝1：如果剩下的饼干不够空手的小朋友了，那么直接返回        int zeroCount = 0;        for (int count : bucket) &#123;            if (count == 0) zeroCount++;        &#125;        if (zeroCount &gt; start + 1) return;        //剪枝2：如果有一个人的饼干数目比当前最小还多，剪枝        for (int x : bucket) &#123;            if (x &gt; ans) return;        &#125;        //回溯部分        for (int i = 0; i &lt; k; i++) &#123;            //剪枝3：第一个零食包不管给哪个小朋友，所开启的回溯树都一样，只要给一个小朋友就行了，这样的回溯树一下子就少了很多。            //这一步是很重要的，因为如果第一个给不同的人那么就会出现k个一样的树            if (start == n - 1 &amp;&amp; i &gt; 0) return;            //标准回溯代码            bucket[i] += cookies[start];            backtrack(bucket, start - 1);            bucket[i] -= cookies[start];        &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/Learning-Records/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/Learning-Records/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-1155-掷骰子等于目标和的方法数"><a href="#leetcode-1155-掷骰子等于目标和的方法数" class="headerlink" title="leetcode_1155. 掷骰子等于目标和的方法数"></a>leetcode_1155. 掷骰子等于目标和的方法数</h3><p>使用记忆化搜索，首先发现存在着子问题，那么使用dp的办法没问题。然后确定子问题是什么，显然当最后一个骰子掷出一个数字m,那么后面的问题就变成n-1个骰子得到和为target-m的问题。那么就可以实现递归解决。定义数组，两个维度分别表示骰子数目和骰子和，最后答案为dfs(n,target).<br>显然递归式子好写，难点在于这个不要+1，我总是认为需要加一，而实际上最后的次数就是基于前面的次数，而不是加一。只需要一个for循环，列出当前的可能值，然后加上n-1个骰子达到j-x的总数就行。<br>注意定义边界情况当j&lt;0时候说明不存在这种情况，i&#x3D;&#x3D;0时要判断，j&#x3D;&#x3D;0说明这种情况是存在的返回1，j!&#x3D;0说明不存在直接返回0；</p><pre><code class="java">       Integer MOD = 1000000007;    int[][] dp;    public int numRollsToTarget(int n, int k, int target) &#123;        if (target &lt; n || target &gt; n * k) &#123;            return 0; // 无法组成 target        &#125;        dp=new int[n+1][target+1];        for(int i=0;i&lt;=n;i++)&#123;            Arrays.fill(dp[i],-1);        &#125;        return dfs(n, target, k);    &#125;    public int dfs(int i, int j, int k) &#123;//i个骰子得到数字为j的次数        if (j &lt; 0) return 0;        if (i == 0) return j == 0 ? 1 : 0;        if(dp[i][j]!=-1) return dp[i][j];        int res = 0;        for (int x = 1; x &lt;= k; x++) &#123;            res = (res + dfs(i - 1, j-x, k)) % MOD;        &#125;        return dp[i][j]=res;    &#125;</code></pre><h3 id="leetcode-740-删除并获得点数"><a href="#leetcode-740-删除并获得点数" class="headerlink" title="leetcode_740. 删除并获得点数"></a>leetcode_740. 删除并获得点数</h3><p>思路没有问题，但是一个数选择或者不选，应该想到动态规划中的打家劫舍问题。选或者不选影响下一个数的选择，所以递推的表达式:dfs(i)&#x3D;Max(dfs(i-1),dfs(i-2)+nums[i]),同样适用于这一题，只考虑一边，从头向后或者从后向前都可以进行。然后每次决定选择或者不选择，记住dp的含义是什么：到下标i处所获得的最大得分。</p><pre><code class="java">    public static int deleteAndEarn(int[] nums) &#123;        int[] cnt = new int[10002];//使用计数排序        int max = 0;        for (int num : nums) &#123;            cnt[num]++;            max = Math.max(num, max);        &#125;        int[] dp = new int[max + 1];//到第i个数为止的最大得分        dp[1]=cnt[1];        for (int i = 2; i &lt;=max; i++) &#123;            dp[i]=Math.max(dp[i-1],dp[i-2]+i*cnt[i]);        &#125;        return dp[max];&#125;</code></pre><h3 id="leetcode-2327-知道秘密的人数"><a href="#leetcode-2327-知道秘密的人数" class="headerlink" title="leetcode_2327. 知道秘密的人数"></a>leetcode_2327. 知道秘密的人数</h3><p>题目理解起来有点困难。<br>首先将人分成三类：<br>                 1.在第i天知道秘密并且可以分享的人<br>                 2.在第i天知道了秘密但是不能分享的人<br>                 3.在第i天已经忘记了秘密的人（不计算）<br>显然，我们只需要计算前两种就可以知道第i天知道秘密的人数，就可以知道答案了。那么如何计算呢，对于第一种人，我们可以使用数组来记录，使用f[i]表示第i天已知且分享的人数，那么对于(i+delay,i+forget)天内都需要加上f[i]。<br>对于第二种人，那么就是他已经知道了秘密的日期为k，但是k+delay&gt;&#x3D;i,也就是第i天他无法分享秘密，那么cnt&#x3D;cnt+f[k]</p><pre><code class="java">   static final int MOD=(int) 1e9 + 7;    public static int peopleAwareOfSecret(int n, int delay, int forget) &#123;        int[] diff=new int[n];        diff[0]=1;//初始只有一个人知道秘密,表示第n天已经知道了秘密且可以分享给别人的人数        int cntB=0;//表示目前知道秘密但是不能分享的人数        for(int i=0;i&lt;n;i++)&#123;            if(i+delay&gt;=n)&#123;//说明这个人是第n天知道秘密但是不能分享秘密的人                cntB=(cntB+diff[i])%MOD;            &#125;            for(int j=i+delay;j&lt;Math.min(i+forget,n);j++)&#123;                diff[j]=(diff[j]+diff[i])%MOD;            &#125;        &#125;        return (diff[n - 1] + cntB) % MOD;    &#125;</code></pre><h3 id="leetcode-650-只有两个键的键盘"><a href="#leetcode-650-只有两个键的键盘" class="headerlink" title="leetcode_650. 只有两个键的键盘"></a>leetcode_650. 只有两个键的键盘</h3><p>显然可以使用动态规划来做，那么首先我需要i个字符，那么最好能进行一次粘贴很多个字符，然后尽快达到要求，但是题目的要求就让复制之后不能随意改变，因为每次复制都是直接复制所有的字符。所以考虑如何复制，在什么时候复制最好？枚举小于i的数，选择i的最大因子，这样一来我的操作次数就能大大降低。</p><p>细节：对于i来说，j是他的因子，那么j,i&#x2F;j都是他的因子，其中必定有一个小于$\sqrt{i}$,因此我们直接枚举到$\sqrt{i}$就可以找到最大因子了，从而找到最优解。</p><pre><code class="java">    public int minSteps(int n) &#123;        int[] dp=new int[n+1];        dp[0]=0;        dp[1]=0;        for(int i=1;i&lt;=n;i++)&#123;            //枚举i的最大因子            dp[i]=Integer.MAX_VALUE;            for(int j=1;j&lt;=i;j++)&#123;                if(i%j==0)&#123;                    dp[i]=Math.min(dp[i],dp[j]+i/j);                    dp[i]=Math.min(dp[i],dp[i/j]+j);                &#125;            &#125;        &#125;        return dp[n];    &#125;</code></pre><h3 id="leetcode-面试题-08-11-硬币"><a href="#leetcode-面试题-08-11-硬币" class="headerlink" title="leetcode_面试题 08.11. 硬币"></a>leetcode_面试题 08.11. 硬币</h3><p>这种由于前后使用顺序带来重复计算的问题，应该考虑如何避免这种问题，在这里是直接考虑先使用小的硬币，再使用大的硬币。</p><p>补充说明：为什么正确解法的coin要在外面？</p><p>因为这样可以保证使用第二个硬币尝试的时候，dp中 只有 第一个硬币 尝试的结果</p><p>即：</p><p>dp[6]在使用第一个硬币时，等于dp[5] &#x3D;1。</p><p>dp[6]在使用第二个硬币时，等于dp[1] &#x3D; 1(这是第一个硬币的组合结果)</p><p>而错误解法中，dp[6]在第一个硬币尝试的时候，即dp[5]中有 尝试第一个、第二个硬币 的结果</p><pre><code class="java">    //使用一维数组进行记忆化搜索存在重复计算的问题,这是因为使用硬币的顺序会对结果产生影响，所以考虑先使用小的硬币进行计算从而避免出现计算    //例如6:5+1，1+5是同样的，我们先把1的情况计算完，再计算5    int MOD = (int) 1e9 + 7;    int[] dp;//使用前i种硬币组成j的种数    int[] coins = new int[]&#123;1,5,10,25&#125;;    public int waysToChange(int n) &#123;        dp = new int[n+1];        dp[0] = 1;        //dp[i]=dp[i]+dp[i-coin]        for(int coin:coins)&#123;            for(int i=coin;i&lt;=n;i++)&#123;                dp[i]=(dp[i]+dp[i-coin])%MOD;            &#125;        &#125;        return dp[n];    &#125;</code></pre><h3 id="leetcode-2915-和为目标值的最长子序列的长度"><a href="#leetcode-2915-和为目标值的最长子序列的长度" class="headerlink" title="leetcode_2915. 和为目标值的最长子序列的长度"></a>leetcode_2915. 和为目标值的最长子序列的长度</h3><p>首先考虑是否存在子问题。 显然这是一个关于选或者不选的问题，那么考虑最后一个数。 如果选择了那么问题变成求n-1个数target&#x3D;target-nums[n-1]； 如果不选那么问题变成n-1个数target&#x3D;target</p><p>不难得到递推式： dfs(i,target)&#x3D;max(dfs(n-1,target-nums[i]),dfs(n-1,target));</p><p>注意dfs的含义则是前n个数目标和为target的子序列的最大长度。</p><p>出口显然就是当i&lt;0或者target&lt;0时返回。以及target&#x3D;&#x3D;0时找到了正确答案。</p><pre><code class="java">    Integer[] num;    int[][] dp;    public int lengthOfLongestSubsequence(List&lt;Integer&gt; nums, int target) &#123;        num = nums.toArray(new Integer[0]);        int n = nums.size();        dp = new int[n + 1][target + 1];        for (int i = 0; i &lt;= n; i++) &#123;            Arrays.fill(dp[i], -1);        &#125;        int ans = dfs(n - 1, target);        return ans &lt;0?-1:ans;    &#125;    public int dfs(int i, int target) &#123;        if(target==0) return 0;        if (i &lt; 0||target&lt;0) return Integer.MIN_VALUE/2;        if (dp[i][target] != -1) return dp[i][target];        return dp[i][target] = Math.max(dfs(i - 1, target), dfs(i - 1, target - num[i]) + 1);    &#125;</code></pre><h3 id="leetcode-2707-字符串中的额外字符"><a href="#leetcode-2707-字符串中的额外字符" class="headerlink" title="leetcode_2707. 字符串中的额外字符"></a>leetcode_2707. 字符串中的额外字符</h3><p>考虑是用什么方法解决问题，思来想去。还是动态规划适合这个题目，但是这个的动态规划和其他的动态规划有一点不一样。<br>仍然是寻找子问题：<br>设 n 为 s 的长度。我们可以：</p><ul><li>（1）直接跳过 s 的最后一个字符，那么问题变成 s 的前 n−1 个字符的子问题。</li><li>（2）【枚举选哪个】,考虑从s[j]到i的子字符串能否在字典中找到，如果找到了，那么子问题变成了s的前j-1个字符的子问题。</li></ul><p>转换成动态规划的递推式;</p><ul><li>（1）dfs(i)&#x3D;dfs(i−1)+1</li><li>（2）dfs(i)&#x3D;min(dfs(j-1))</li></ul><p>递归边界：显然当i&lt;0时需要返回0。</p><pre><code class="java">   Set&lt;String&gt; set;    int[] dp;    String s;    public int minExtraChar(String s, String[] dictionary) &#123;        int n = s.length();        this.s = s;        dp = new int[n];        Arrays.fill(dp, -1);       for(String x:dictionary) set.add(x);        set.addAll(Arrays.asList(dictionary));        return dfs(n - 1);    &#125;    public int dfs(int i) &#123;        if (i &lt; 0) return 0;        if (dp[i] != -1) return dp[i];        int res = dfs(i - 1) + 1;//不选择这个字符的情况        for (int j = 0; j &lt;= i; j++) &#123;//枚举子串            if (set.contains(s.substring(j, i + 1))) &#123;                res = Math.min(dfs(j - 1), res);            &#125;        &#125;        return dp[i] = res;    &#125;</code></pre><h3 id="leetcode-2767-将字符串分割为最少的美丽子字符串"><a href="#leetcode-2767-将字符串分割为最少的美丽子字符串" class="headerlink" title="leetcode_2767. 将字符串分割为最少的美丽子字符串"></a>leetcode_2767. 将字符串分割为最少的美丽子字符串</h3><p>动态规划，使用记忆化搜索的方式。<br>首先想到子问题是什么，dfs的含义是什么。子问题显然就是当从末尾选择一个满足要求的字符后剩下的字符最小分割的数目。所以dfs的含义就是分割到i位置时的最小字符串数目。<br>首先预处理一下5的幂，这里需要处理7个字符串。处理之后开始进行dfs.从后向前枚举可以更方便的判断是否存在前导0，判断2进制是否为5的幂则是判断s.substring(j,i)是否在集合内。最后取这些所有情况的最小值就是答案。如果不存在这样的答案则返回-1。</p><pre><code class="java">    String s;    Set&lt;String&gt; set;//预处理5的幂    int[] cache;    public int minimumBeautifulSubstrings(String s) &#123;        this.s = s;        int n = s.length();        cache = new int[n + 1];        Arrays.fill(cache, -1);        set = new HashSet&lt;&gt;();        for (int i = 0; i &lt; 8; i++) &#123;            set.add(Integer.toBinaryString((int) Math.pow(5, i)));//预处理        &#125;        int res = dfs(n);        return res==Integer.MAX_VALUE/2?-1:res;    &#125;    // 定义 dfs(i) 表示分割 s[:i] 的最少数目    //枚举 0 &lt; j &lt; i，看 s[j:i] 是否为美丽子字符串,且取所有情况的最小值    //递归边界： dfs(0) = 0, 表示分割完了s，是一种合法方案    // 递归入口： dfs(len(s)) 若不存在合法情况，返回-1    public int dfs(int i) &#123;        if(i==0) return 0;        if(cache[i]!=-1) return cache[i];        int res=Integer.MAX_VALUE/2;        for(int j=i-1;j&gt;=0;j--)&#123;            if(s.charAt(j)!=&#39;0&#39;&amp;&amp;set.contains(s.substring(j,i)))&#123;//不包含前导0，且为5的幂                res=Math.min(res,dfs(j)+1);            &#125;        &#125;        return cache[i]=res;    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心</title>
      <link href="/Learning-Records/%E8%B4%AA%E5%BF%83/"/>
      <url>/Learning-Records/%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-2910-合法分组的最少组数"><a href="#leetcode-2910-合法分组的最少组数" class="headerlink" title="leetcode_2910. 合法分组的最少组数"></a>leetcode_2910. 合法分组的最少组数</h3><p>首先考虑就是分组的条件，因为没注意到具体条件走了不少的弯路。然后就是贪心的进行分组，只要能满足分组情况那么就直接分，一旦出现一个不满足的情况说明这个分组数目不满足需要进行k–</p><pre><code class="java">    public static int minGroupsForValidAssignment(int[] nums) &#123;        //贪心的考虑：分组之后只能出现两个数字，那么显然分成k+1和k的情况下得到的组数是最少的，不用考虑k,k-1        // 在可以分组的前提下，分出的 k+1 越多，组数就越少        //但是什么时候是可以分组呢？什么时候不可以分组呢？        // 显然只考虑分成k和k+1的组就行，因为如果分成k,k-1那么k--就可以了，一次只考虑一种情况        //如果都考虑只会做不出来        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        for (int x : nums) map.put(x, map.getOrDefault(x, 0) + 1);        Collection&lt;Integer&gt; numberOfOccurrences = map.values();        int k = Integer.MAX_VALUE;        for (int y : numberOfOccurrences) &#123;//获得这些数中的最小的出现次数            k = Math.min(k, y);        &#125;        for(;;k--)&#123;//从后向前遍历，得到答案就直接返回，节省时间            int ans=0;            for(int c:map.values())&#123;                int g = c / k;                int m = c % k;                if(g &lt; m)&#123;//多出来的这些数加不到前面的每一个组中去，说明这样分是不对的                    ans=0;                    break;                &#125;                ans+=(c+k)/(k+1);//获取所有的分组            &#125;            if(ans&gt;0) return ans;        &#125;    &#125;</code></pre><h3 id="leetcode-2680-最大或值"><a href="#leetcode-2680-最大或值" class="headerlink" title="leetcode_2680. 最大或值"></a>leetcode_2680. 最大或值</h3><p>计算最大或值，首先应该使得最后的答案的二进制长度尽可能长，那么k次左移的机会用在一个数上得到的答案要比用在多个数上得到的答案更优，所以贪心的想法就体现在这里。<br>预处理每个$nums[i]$左侧元素的或值 $pre$，以及右侧元素的或值 $suf$，从而快速计算出把 $nums[i]$ 乘 k 次 2后的所有元素的或值。进一步地，只需要预处理右侧元素的或值，左侧的或值可以一边枚举一边计算。</p><pre><code class="java">  public int matrixSum(int[][] nums) &#123;        int n= nums.length;        int m=nums[0].length;        for (int[] num : nums) &#123;            Arrays.sort(num);        &#125;        int ans=0;        for(int j=m-1;j&gt;=0;j--)&#123;            int maxScore=0;            for (int[] num : nums) &#123;                maxScore = Math.max(maxScore, num[j]);            &#125;            ans+=maxScore;        &#125;        return ans;    &#125;</code></pre><h3 id="leetcode-2914-使二进制字符串变美丽的最少修改次数"><a href="#leetcode-2914-使二进制字符串变美丽的最少修改次数" class="headerlink" title="leetcode_2914. 使二进制字符串变美丽的最少修改次数"></a>leetcode_2914. 使二进制字符串变美丽的最少修改次数</h3><p>最小的贪心单位是2,所以只需要判断每两个字符之间的相等情况。</p><pre><code class="java">    public int minChanges(String s) &#123;        int n=s.length();        int ans=0;        for(int i=0;i&lt;n;i+=2)&#123;            if(s.charAt(i)!=s.charAt(i+1))ans++;        &#125;        return ans;    &#125;</code></pre><h3 id="leetcode-2708-一个小组的最大实力值"><a href="#leetcode-2708-一个小组的最大实力值" class="headerlink" title="leetcode_2708. 一个小组的最大实力值"></a>leetcode_2708. 一个小组的最大实力值</h3><p>经典的贪心以及分类讨论的问题：<br>    贪心思想：显然要得到最大乘积，所有的正数都应该加入乘积中去<br>    对于所有的负数，如果是偶数个负数那么直接累乘<br>    如果奇数个负数那么就需要考虑选择绝对值最大的偶数个负数<br>    如果存在0，最好是不选择，但是如果数组中不存在正数结果那么就选择0<br>设置计数器，记录正数和负数的操作只要这个计数器大于0，说明一定是有一种方式使得ans最大为正确答案。如果cnt&#x3D;&#x3D;0说明正数和负数都不能选，此时就需要看是否存在0，存在0返回0，不存在0返回最大的负数。</p><pre><code class="java">  public static long maxStrength(int[] nums) &#123;        long ans=1;        int zero=0;        List&lt;Integer&gt; negative=new ArrayList&lt;&gt;();        List&lt;Integer&gt; positive=new ArrayList&lt;&gt;();        for(int x:nums)&#123;            if(x&lt;0) &#123;                negative.add(x);            &#125;else if(x&gt;0)&#123;               positive.add(x);            &#125;else &#123;               zero++;            &#125;        &#125;        Integer[] a = negative.toArray(new Integer[0]);        Arrays.sort(a);        int cnt = 0;        for(int x:positive) &#123;            ans*=x;            cnt++;        &#125;        for(int i=0;i&lt;negative.size()-1;i+=2)&#123;            ans*=((long)a[i] *a[i+1]);            cnt+=2;        &#125;        if(cnt&gt;0) return ans;        else &#123;            if(zero&gt;0) return 0;            else return nums[0];        &#125;    &#125;</code></pre><h3 id="leetcode-2740-找出分区值"><a href="#leetcode-2740-找出分区值" class="headerlink" title="leetcode_2740. 找出分区值"></a>leetcode_2740. 找出分区值</h3><p>贪心：直接将数组排序，从头到尾遍历，找到两个数之间的差值最小的为多少就是答案。前面的部分归nums1,后面的部分归nums2。</p><pre><code class="java">    public int findValueOfPartition(int[] nums) &#123;        Arrays.sort(nums);        int n=nums.length;        int ans=Integer.MAX_VALUE;        for(int i=1;i&lt;n;i++)&#123;            ans=Math.min(ans,nums[i]-nums[i-1]);        &#125;        return  ans;    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前缀和（包含前缀后缀分解）</title>
      <link href="/Learning-Records/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/Learning-Records/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-1423-可获得的最大点数"><a href="#leetcode-1423-可获得的最大点数" class="headerlink" title="leetcode_1423. 可获得的最大点数"></a>leetcode_1423. 可获得的最大点数</h3><p>前缀和以及后缀和的应用：一共只能取k次，那么枚举取开头位置的次数为i,末尾的次数就是k-i次，最后计算出最大值。</p><pre><code class="java">    public int maxScore(int[] cardPoints, int k) &#123;        //贪心的思想，一共只能取k次，那么枚举取开头位置的次数为i,末尾的次数就是k-i次，最后计算出最大值。        //使用前缀和以及后缀和来做        int n = cardPoints.length;        int[] prefix=new int[n+1];        int[] suffix=new int[n+1];        for(int i=0;i&lt;k;i++)&#123;            prefix[i+1] = prefix[i] + cardPoints[i];        &#125;        for(int i=n-1;i&gt;n-k-1;i--)&#123;            suffix[i] = suffix[i+1] + cardPoints[i];        &#125;        int res = 0;        //前面取i个元素，后面取k-i个元素        for(int i=0;i&lt;=k;i++)&#123;            res = Math.max(res,prefix[i]+suffix[n-k+i]);        &#125;        return res;    &#125;</code></pre><h3 id="leetcode-2909-元素和最小的山形三元组-II"><a href="#leetcode-2909-元素和最小的山形三元组-II" class="headerlink" title="leetcode_2909. 元素和最小的山形三元组 II"></a>leetcode_2909. 元素和最小的山形三元组 II</h3><p>使用前后缀分解的办法，记录每个数的左侧最小以及右侧最小，并且判断这个数是否满足山形的要求。</p><pre><code class="java">    public static int minimumSum(int[] nums) &#123;        int n= nums.length;        int[] left_minimum=new int[n];        int[] right_minimum=new int[n];        int Min=Integer.MAX_VALUE;        for(int i=1;i&lt;n;i++)&#123;            Min=Math.min(Min,nums[i-1]);            left_minimum[i]=Min;        &#125;        Min=Integer.MAX_VALUE;        for(int i=n-2;i&gt;=0;i--)&#123;            Min=Math.min(Min,nums[i+1]);            right_minimum[i]=Min;        &#125;        int res=Integer.MAX_VALUE;        for(int i=1;i&lt;n-1;i++)&#123;            if(nums[i]&gt;left_minimum[i]&amp;&amp;nums[i]&gt;right_minimum[i]) &#123;                res = Math.min(res, right_minimum[i] + left_minimum[i] + nums[i]);            &#125;        &#125;        return res==Integer.MAX_VALUE?-1:res;    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>List 操作</title>
      <link href="/Learning-Records/List-%E6%93%8D%E4%BD%9C/"/>
      <url>/Learning-Records/List-%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="List直接转换到int"><a href="#List直接转换到int" class="headerlink" title="List直接转换到int[]"></a>List直接转换到int[]</h3><p><code>int[] array = list.stream().mapToInt(Integer::intValue).toArray();</code><br>list.stream()表示将list转换为一个流对象，.mapToInt(Integer::intValue)表示将流中的每个Integer类型的元素映射为其对应的int类型，最后使用.toArray()将转换后的流生成一个int类型的数组。这种写法可以避免了循环遍历整个列表，并且使用了Java 8的lambda表达式来实现代码简洁易读。</p><p>一般可以使用例如：<code>list.toArray(new int[0][])</code>或者 <code>list.toArray(new int[0])</code></p><h3 id="对List进行排序"><a href="#对List进行排序" class="headerlink" title="对List进行排序"></a>对List进行排序</h3><p>注意是对实体list调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.sort((o1, o2) -&gt; o1[<span class="number">1</span>] == o2[<span class="number">1</span>] ? o1[<span class="number">0</span>] - o2[<span class="number">0</span>] : o2[<span class="number">1</span>] - o1[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>或者：Collections.sort(list,(o1,o2)…)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>双周赛115</title>
      <link href="/Learning-Records/%E5%8F%8C%E5%91%A8%E8%B5%9B115/"/>
      <url>/Learning-Records/%E5%8F%8C%E5%91%A8%E8%B5%9B115/</url>
      
        <content type="html"><![CDATA[<h2 id="双周赛115"><a href="#双周赛115" class="headerlink" title="双周赛115"></a>双周赛115</h2><p>leetcode_2899. 上一个遍历的整数<br>leetcode_2900. 最长相邻不相等子序列 I<br>leetcode_2901. 最长相邻不相等子序列 II</p><p>第二和第三题，由于是求子序列的问题，那么首先可以想到dp的办法，问题解决起来不算困难，但是存在优化的方法。那就是记录答案时考虑只记录下标，最后需要返回答案的时候遍历一次数组，直接返回，这样可以大大减少对List的操作，从而减少时间上的开销。然后就是算法的实现方面，也基本没什么问题，从后向前去找最大的满足要求的值就可以了。给出第三题未优化的版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getWordsInLongestSubsequence</span><span class="params">(<span class="type">int</span> n, String[] words, <span class="type">int</span>[] groups)</span> &#123;</span><br><span class="line">       <span class="comment">//子序列问题，应该想到dp求解，考虑右侧端点位置的元素</span></span><br><span class="line">       <span class="comment">//以右侧端点结尾的子序列的最长序列</span></span><br><span class="line">       List&lt;List&lt;String&gt;&gt; dp_list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxlen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       List&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       s.add(words[<span class="number">0</span>]);</span><br><span class="line">       dp_list.add(<span class="number">0</span>, s);</span><br><span class="line"></span><br><span class="line">       List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(s);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">           List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">               <span class="comment">//遍历子序列</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">Mlen</span> <span class="operator">=</span> temp.size();</span><br><span class="line">               <span class="keyword">if</span> (groups[j] != groups[i] &amp;&amp; words[j].length() == words[i].length() &amp;&amp; hammingDistance(words[i], words[j])) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (dp_list.get(j).size() &gt; Mlen) &#123;<span class="comment">//找到符合条件中的最大值</span></span><br><span class="line">                       temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(dp_list.get(j));</span><br><span class="line">                       Mlen = temp.size();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           temp.add(words[i]);</span><br><span class="line">           dp_list.add(temp);</span><br><span class="line">           <span class="keyword">if</span> (dp_list.get(i).size() &gt; maxlen) &#123;<span class="comment">//记录答案</span></span><br><span class="line">               maxlen = dp_list.get(i).size();</span><br><span class="line">               ans = dp_list.get(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hammingDistance</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length();</span><br><span class="line">       <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (a.charAt(i) != b.charAt(i)) &#123;</span><br><span class="line">               flag++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> flag == <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="/Learning-Records/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/Learning-Records/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前缀树Trie-字典树"><a href="#前缀树Trie-字典树" class="headerlink" title="前缀树Trie(字典树)"></a>前缀树Trie(字典树)</h2><p>Trie树的意义：<br> Trie树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串&#x2F;字符前缀」是否存在的数据结构。<br> 其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符是什么」。这样来形成一个树的形状，可以快速判断某个字符是否在树中(或者是否包含这个字符的前缀)<br> <img src="/Learning-Records/image-1.png" alt="Trie"></p><h3 id="Trie树的构建：使用二维数组或者使用TrieNode"><a href="#Trie树的构建：使用二维数组或者使用TrieNode" class="headerlink" title="Trie树的构建：使用二维数组或者使用TrieNode"></a>Trie树的构建：使用二维数组或者使用TrieNode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">100009</span>; <span class="comment">// 直接设置为十万级</span></span><br><span class="line">    <span class="type">int</span>[][] trie;</span><br><span class="line">    <span class="type">int</span>[] count;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        trie = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">26</span>];</span><br><span class="line">        count = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (trie[p][u] == <span class="number">0</span>) trie[p][u] = ++index;</span><br><span class="line">            p = trie[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">        count[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (trie[p][u] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = trie[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count[p] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (trie[p][u] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = trie[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用TrieNode:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> end;</span><br><span class="line">        TrieNode[] tns = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrieNode root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.tns[u] == <span class="literal">null</span>) p.tns[u] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            p = p.tns[u]; </span><br><span class="line">        &#125;</span><br><span class="line">        p.end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.tns[u] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p.tns[u]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.tns[u] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p.tns[u]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode-648-单词替换"><a href="#leetcode-648-单词替换" class="headerlink" title="leetcode_648. 单词替换"></a>leetcode_648. 单词替换</h3><p>使用前缀树查找字符是否存在前缀，如果存在返回前缀，不存在直接返回字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">       <span class="type">boolean</span> end;</span><br><span class="line">       TrieNode[] tns = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   TrieNode root=<span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span> (p.tns[u] == <span class="literal">null</span>) p.tns[u] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">           p = p.tns[u];</span><br><span class="line">       &#125;</span><br><span class="line">       p.end = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    String  <span class="title function_">search</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span> (p.tns[u] == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">if</span> (p.tns[u].end) <span class="keyword">return</span> s.substring(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">           p = p.tns[u];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> s;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">replaceWords</span><span class="params">(List&lt;String&gt; dictionary, String sentence)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(String str:dictionary) insert(str);</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       String[] s = sentence.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (String x : s) &#123;</span><br><span class="line">          ans.append(search(x)).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans.toString().trim();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>周赛_367</title>
      <link href="/Learning-Records/%E5%91%A8%E8%B5%9B-367/"/>
      <url>/Learning-Records/%E5%91%A8%E8%B5%9B-367/</url>
      
        <content type="html"><![CDATA[<p>主要内容为一个滑动窗口类问题+一个遍历记录最值问题。需要注意的地方就是记录最值之类的问题的思想。再碰到这类的问题应当想到这个</p><h3 id="leetcode-2904-最短且字典序最小的美丽子字符串"><a href="#leetcode-2904-最短且字典序最小的美丽子字符串" class="headerlink" title="leetcode_2904. 最短且字典序最小的美丽子字符串"></a>leetcode_2904. 最短且字典序最小的美丽子字符串</h3><p>2023年10月18日下午2点37分<br>题目要求找到最短的美丽子字符串，其次还要求字典序最小，应该找到符合的子串后比较字典序。碰到这样的子串类问题，考虑使用同向双指针的方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  String <span class="title function_">shortestBeautifulSubstring</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=s.length();</span><br><span class="line">    String ans=<span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>;<span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minlen=Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span> (right&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars[right]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">0</span>) &#123;</span><br><span class="line">                left = right;<span class="comment">//第一个1处</span></span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;<span class="comment">//计数器增1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;k)&#123;</span><br><span class="line">            <span class="comment">//窗口左移,到下一个1处</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">while</span> (chars[left]==<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==k)&#123;<span class="comment">//判断窗口内的元素是否是最短的</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> s.substring(left, right+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>((ans==<span class="literal">null</span>)||minlen&gt;substring.length()||((minlen==substring.length())&amp;&amp;judgingTheDictionaryOrder(ans,substring))) &#123;</span><br><span class="line">                ans= substring;</span><br><span class="line">                minlen=substring.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans==<span class="literal">null</span>?<span class="string">&quot;&quot;</span>:ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">judgingTheDictionaryOrder</span><span class="params">(String a,String b)</span>&#123;</span><br><span class="line">    <span class="comment">//比较a与b的字典序，如果b的字典序更小则返回true</span></span><br><span class="line">    <span class="type">int</span> n=a.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.charAt(i)&gt;b.charAt(i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.charAt(i)&lt;b.charAt(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode-2905-找出满足差值条件的下标-II"><a href="#leetcode-2905-找出满足差值条件的下标-II" class="headerlink" title="leetcode_2905. 找出满足差值条件的下标 II"></a>leetcode_2905. 找出满足差值条件的下标 II</h3><p>和之前的leetcode_2874. 有序三元组中的最大值 II是很相似的类型，同样是需要在O(N)的时间复杂度内找到满足条件的值，但是遍历一次就要找到，那么想到使用记录数来记录最大最小值，从而满足需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findIndices(<span class="type">int</span>[] nums, <span class="type">int</span> indexDifference, <span class="type">int</span> valueDifference) &#123;</span><br><span class="line">    <span class="type">int</span> n=nums.length;</span><br><span class="line">    <span class="type">int</span> maxInd=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minInd=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=indexDifference;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="type">int</span> i=j-indexDifference;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;nums[maxInd])&#123;</span><br><span class="line">            maxInd=i;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;nums[minInd])&#123;</span><br><span class="line">            minInd=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[maxInd]-nums[j]&gt;=valueDifference)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;maxInd,j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]-nums[minInd]&gt;=valueDifference)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;minInd,j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/Learning-Records/Markdown/"/>
      <url>/Learning-Records/Markdown/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-826-安排工作以达到最大收益"><a href="#leetcode-826-安排工作以达到最大收益" class="headerlink" title="leetcode_826. 安排工作以达到最大收益"></a>leetcode_826. 安排工作以达到最大收益</h3><p>贪心法：目标是最大利润，但是利润的获取是要建立在难度的许可之下的，所以首先对难度和工人能力排序，对于每个工人记录下他的能力下所能取得的最大利润，对于后面的工人，那么就需要判断他的能力能否突破上一个人的上限获取到更大的利润，使用一个数来记录最大利润就行。需要注意的是在进行while循环的时候注意j可能会超出数组范围，需要加入限制条件。</p><pre><code class="java">  public static int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) &#123;        int premaxprofit=Integer.MIN_VALUE;        int ans=0;        int n= difficulty.length;        Arrays.sort(worker);//先对工人排序        int[][] d=new int[n][2];        for(int i=0;i&lt;n;i++)&#123;            d[i][0]=difficulty[i];            d[i][1]=profit[i];        &#125;        Arrays.sort(d,(o1, o2) -&gt; o1[0]-o2[0]);//按照难度排序        int j=0;        for(int i=0;i&lt; worker.length;i++) &#123;            while (j&lt;n&amp;&amp;worker[i]&gt;=d[j][0])&#123;                premaxprofit=Math.max(premaxprofit,d[j++][1]);            &#125;            ans+=(premaxprofit==Integer.MIN_VALUE?0:premaxprofit);        &#125;        return ans;    &#125;</code></pre><h3 id="leetcode-8028-执行操作使两个字符串相等"><a href="#leetcode-8028-执行操作使两个字符串相等" class="headerlink" title="leetcode_8028. 执行操作使两个字符串相等"></a>leetcode_8028. 执行操作使两个字符串相等</h3><p>首先最常用的贪心是错误的，贪心是做不出这题的。采用dp的办法。那么既然考虑dp那么可以从开头也可以从结尾开始考虑情况。从结尾字符开始考虑。首先存在两种操作，分别记为op1和op2.</p><p>如果当前字符不相等采用op1：那么接下来的字符就可以免费翻转一次，代价+x<br>如果当前字符不等采用op2：那么下一个字符就需要被翻转，代价+1</p><p>所以需要记录免费翻转次数j,上一个字符是否采用了op2:PreRev</p><p>由于存在PreRev所以判断两个字符相等也变得复杂不再是简单的<code>s1[i]==s2[i]</code>,而是变成了<code>（s1[1]==s2[i]）==(PreRev==0)</code>,存在情况：两个字符本来不相等，但是当前这个需要翻转而出现相等的情况。</p><p>到这里dp所需要的元素都很明了：PreRev,j,i 也就是一个三维的数组，数组中存放的则是最小代价。</p><p>对于s1[i]!&#x3D;s2[i]:分成两种：采用op1以及op2:分别为dfs(i-1,j+1,0)+x,dfs(i-1,j,1)+1,同时j&gt;0的情况dfs(i-1,j-1,0),取这三者的最小值即可。</p><pre><code class="java">    public  int minOperations(String s1, String s2, int x) &#123;        //采用dp的方法进行计算        int n=s1.length();        char[] s = s1.toCharArray();        char[] t = s2.toCharArray();        int diff=0;        for (int i = 0; i &lt; n; i++) &#123;            if (s[i] != t[i]) &#123;                diff ^= 1;            &#125;        &#125;        if(diff&gt;0) return -1;        int[][][] dp=new int[n][n+1][2];        for (int i = 0; i &lt; n; i++) &#123;            for (int j = 0; j &lt;= n; j++) &#123;                Arrays.fill(dp[i][j], -1);// -1 表示没有计算过            &#125;        &#125;        return dfs(s,t,x,n-1,0,0,dp);    &#125;    public  int dfs(char[] s, char[] t, int x, int i,int j,int PreRev,int[][][] dp)&#123;        if(i&lt;0)&#123;//递归边界            return j&gt;0|| PreRev&gt;0?Integer.MAX_VALUE/2:0;        &#125;        if(dp[i][j][PreRev]!=-1)&#123;            //之前计算过这个值            return dp[i][j][PreRev];        &#125;        if(s[i]==t[i]&amp;&amp;PreRev==0)&#123;//当前字符不需要翻转            return dfs(s,t,x,i-1,j,0,dp);        &#125;        int res=Math.min(dfs(s,t,x,i-1,j+1,0,dp)+x,dfs(s,t,x,i-1,j,1,dp)+1);        if(j&gt;0)&#123;            res=Math.min(res,dfs(s,t,x,i-1,j-1,0,dp));        &#125;        dp[i][j][PreRev]=res;        return res;    &#125;</code></pre><h3 id="leetcode-576-出界的路径数"><a href="#leetcode-576-出界的路径数" class="headerlink" title="leetcode_576. 出界的路径数"></a>leetcode_576. 出界的路径数</h3><p>考虑使用动态规划解决问题。<br>首先，存在三个变量：i,j,k 分别代表行、列、移动次数，考虑使用三重dp,遍历移动次数，每次移动次数都需要遍历棋盘，找到可以到达的位置。分析这个位置可能出现情况：<br>    可到达的位置不出界，那么当前位置路径数&#x3D;上一个位置路径数+当前位置路径数<br>    可到达的位置出界，那么直接记录一下出界的路径数&#x3D;出界的路径数+上一个位置路径数<br>最后答案就是出界路径数的值.</p><p>需要注意的是要设定初始出发位置的值应该为1</p><pre><code class="java">  public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) &#123;        final int MOD=1000000007;        int[][][] dp=new int[m][n][maxMove+1];        int[][] d=new int[][]&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;        dp[startRow][startColumn][0]=1;//初始位置，路径数为1         int out=0;        for(int k=0;k&lt;maxMove;k++)&#123;//三维dp，每次都是找当前步数下可以到达的位置，坐标全部遍历是为了防止漏掉当前层的可到达位置            for(int i=0;i&lt;m;i++)&#123;                for(int j=0;j&lt;n;j++)&#123;                    int count=dp[i][j][k];//路径数                    if(count&gt;0)&#123;                        for(int[] dirs:d)&#123;                            int i1=i+dirs[0];                            int j1=j+dirs[1];                            if(i1&gt;=0&amp;&amp;i1&lt;m&amp;&amp;j1&gt;=0&amp;&amp;j1&lt;n)&#123;                                //移动之后在界内，更新移动后位置的路径数                                dp[i1][j1][k+1]=(count+dp[i1][j1][k+1])%MOD;                            &#125;                            else &#123;//移动之后在界外，那么就需要将上一个位置所在的路径数全部加到出界数上                                out=(count+out)%MOD;                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return out;    &#125;</code></pre><h3 id="leetcode-1186-删除一次得到子数组最大和"><a href="#leetcode-1186-删除一次得到子数组最大和" class="headerlink" title="leetcode_1186. 删除一次得到子数组最大和"></a>leetcode_1186. 删除一次得到子数组最大和</h3><p>子数组之类的问题：统统是枚举右侧端点，当前这个位置为子序列的右侧端点时的情况：分类讨论，如果不需要删除那么就都是一样的，当必须要删除一个节点时那么首先考虑删除当前节点，或者之前删除过当前不删。一共三类情况，使用dfs的记忆化搜索可能更加便于理解。</p><pre><code class="java">    static int[] num;    static int[][] dp;    public static int maximumSum(int[] arr) &#123;        //枚举右端点        int n = arr.length;        dp = new int[n][2];        num = arr;        int ans = Integer.MIN_VALUE;        for (int i = 0; i &lt; n; i++) &#123;            Arrays.fill(dp[i], Integer.MIN_VALUE);        &#125;        for (int i = 0; i &lt; n; i++)            ans = Math.max(ans, Math.max(dfs(i, 0), dfs(i, 1)));        return ans;    &#125;    public static int dfs(int i, int j) &#123;        if (i &lt; 0) return Integer.MIN_VALUE / 2;//边界        if (dp[i][j] != Integer.MIN_VALUE) &#123;            return dp[i][j];        &#125;        if (j == 0) &#123;            return dp[i][j] = Math.max(dfs(i - 1, 0),0) + num[i];        &#125; else return dp[i][j] = Math.max(dfs(i - 1, 0), dfs(i - 1, 1) + num[i]);    &#125;</code></pre><h3 id="leetcode-918-环形子数组的最大和"><a href="#leetcode-918-环形子数组的最大和" class="headerlink" title="leetcode_918. 环形子数组的最大和"></a>leetcode_918. 环形子数组的最大和</h3><p>环形子数组，可能解决起来很困难。但是反向考虑，正向求解困难那么就反向求解，求出子数组之和的最小值，那么sums-最小值得到的就是横跨边界的子数组的最大值。同样求出不横跨边界的最大值，取两者之间的最大值即可。但是要注意的是子数组最小有可能是整个数组，如果是整个数组那么此时的答案就应该是直接返回不横跨边界的最大值（这种情况sums-最小值&#x3D;&#x3D;0,且max不一定就比0大，可能最后的答案错误为空）。</p><pre><code class="java">public static int maxSubarraySumCircular(int[] nums) &#123;        int n = nums.length;        int maximumSubstring = Integer.MIN_VALUE;        int minimumSubstring = Integer.MAX_VALUE;        int[] dp1 = new int[n];        int[] dp2 = new int[n];        int sums = nums[0];        dp1[0] = nums[0];        dp2[0] =  nums[0];        maximumSubstring = Math.max(dp1[0], maximumSubstring);        minimumSubstring = Math.min(minimumSubstring, dp2[0]);        for (int i = 1; i &lt; n; i++) &#123;            dp1[i] = Math.max(dp1[i - 1] + nums[i], nums[i]);            dp2[i] = Math.min(dp2[i - 1] + nums[i], nums[i]);            maximumSubstring = Math.max(maximumSubstring, dp1[i]);            minimumSubstring = Math.min(minimumSubstring, dp2[i]);            sums += nums[i];        &#125;        if (sums == minimumSubstring) return maximumSubstring;        return Math.max(maximumSubstring, sums - minimumSubstring);    &#125;</code></pre><h3 id="leetcode-1105-填充书架"><a href="#leetcode-1105-填充书架" class="headerlink" title="leetcode_1105. 填充书架"></a>leetcode_1105. 填充书架</h3><p>很明显题目需要使用动态规划的方式。</p><p>值得注意和思考的地方是，记忆化搜索考虑自后向前，自前向后则是递归，显然自后向前的方式更容易考虑</p><p>首先确定子问题是什么？动态规划类的子问题一般都是从后向前考虑，那么子问题显然可以考虑成和原问题相类似的问题：原问题：给定n本书，确定最小高度。子问题：确定最后一层能放的书（最后一本）之后考虑剩下的x本书的最小高度。（必定存在最后一层）。这里最后一本一定在最后一层，但是最后一层不一定只有最后一本，所以需要判断倒数第二本在最后一层或者不在的情况，取这些情况的最小值。<br>定义dfs为从0到i的最小高度<br>枚举最后一层的下标j,那么从j到i的最大高度就是最后一层的高度,而这个j究竟能取到多少不是一次就可以确定的，这需要计算：所以$dfs(i)&#x3D;min(dfs(j-1)+max_{k&#x3D;j}^i book[k][1]$);并且要满足每一层的宽度小于参数selfwidth,<br>那么在枚举最后一层的下标的时候就需要注意这一点，如果宽度超出直接break;<br>最后返回dfs(n-1)</p><pre><code class="java">  int[] dp;    int width;    int[][] book;    public int minHeightShelves(int[][] books, int shelfWidth) &#123;        //考虑dp进行划分子问题：        // 存在子问题，当最后一层是确定的时候，剩下的书组成的最小高度问题是和原问题类似的问题，所以可以使用动态规划        int n = books.length;        dp = new int[n + 1];        Arrays.fill(dp, -1);        width=shelfWidth;        book=books;       return dfs(n-1);    &#125;    public int dfs(int i)&#123;        //定义递归的出口        if(i&lt;0) return 0;//没有书了        if(dp[i]!=-1) return dp[i];        int leftw=width;int maxH=0;int res=Integer.MAX_VALUE;        for(int j=i;j&gt;=0;j--)&#123;//j是这一层的最后一本书，j-1代表了前面的那本            leftw-=book[j][0];            if(leftw&lt;0) break;            maxH=Math.max(book[j][1],maxH);//获取这一层可以放的书的最大高度            res=Math.min(dfs(j-1)+maxH,res);        &#125;        return dp[i]=res;    &#125;</code></pre><h3 id="leetcode-983-最低票价"><a href="#leetcode-983-最低票价" class="headerlink" title="leetcode_983. 最低票价"></a>leetcode_983. 最低票价</h3><p>记忆化搜索。<br>首先确定整个问题的子问题是什么？假设最后一天一定是需要买票的，那么就存在三种情况：买一天的、买七天的、买三十天的，那么我们只需要找到下一个需要买票的位置，再进行记忆化搜索。最后取这些数的最小值。</p><pre><code class="java"> int[] dp;    public int mincostTickets(int[] days, int[] costs) &#123;        int n = days.length;        dp = new int[n];        Arrays.fill(dp, -1);        return dfs(n - 1, days, costs);    &#125;    public int dfs(int i, int[] days, int[] costs) &#123;        if (i &lt; 0) return 0;        if (dp[i] != -1) return dp[i];        int j = -1, k = -1;        for (int m = i; m &gt;= 0; --m) &#123;            if (days[i] - days[m] &gt; 6) &#123;//这个节点需要重新买票                j = m;                break;            &#125;        &#125;        for (int m = i; m &gt;= 0; --m) &#123;            if (days[i] - days[m] &gt; 29) &#123;                k = m;                break;            &#125;        &#125;        dp[i] = Math.min(dfs(i - 1, days, costs) + costs[0], Math.min(dfs(j, days, costs) + costs[1], dfs(k, days, costs) + costs[2]));        //上一个买票的点处，如果超出范围那么直接就是        return dp[i];    &#125;</code></pre><h3 id="leetcode-646-最长数对链"><a href="#leetcode-646-最长数对链" class="headerlink" title="leetcode_646. 最长数对链"></a>leetcode_646. 最长数对链</h3><p>这题首先想到的就是对数组首先需要排序，排序应该按照右侧排序(右侧相同，按照左侧进行升序)，排序完成后就选择添加就行了。贪心：每次添加的都是最小的，这样到最后添加的数目应该就是最大的</p><pre><code class="java">    public static int findLongestChain(int[][] pairs) &#123;        //考虑使用贪心        int n = pairs.length;        Arrays.sort(pairs, (o1, o2) -&gt; o1[1] == o2[1] ? o1[0] - o2[0] : o1[1] - o2[1]);        int left = 0;        int right = 1;        int ans = 1;        while (right &lt; n) &#123;            if (pairs[right][0] &gt; pairs[left][1]) &#123;                //增加链长                left = right;                ans++;            &#125;                 right++;        &#125;        return ans;    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/Learning-Records/hello-world/"/>
      <url>/Learning-Records/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

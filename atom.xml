<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>变强日记</title>
  
  
  <link href="https://xu-jia-wang.github.io/Learning-Records/atom.xml" rel="self"/>
  
  <link href="https://xu-jia-wang.github.io/Learning-Records/"/>
  <updated>2023-10-20T01:56:48.853Z</updated>
  <id>https://xu-jia-wang.github.io/Learning-Records/</id>
  
  <author>
    <name>徐嘉旺</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>双周赛115</title>
    <link href="https://xu-jia-wang.github.io/Learning-Records/%E5%8F%8C%E5%91%A8%E8%B5%9B115/"/>
    <id>https://xu-jia-wang.github.io/Learning-Records/%E5%8F%8C%E5%91%A8%E8%B5%9B115/</id>
    <published>2023-10-20T01:56:21.000Z</published>
    <updated>2023-10-20T01:56:48.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双周赛115"><a href="#双周赛115" class="headerlink" title="双周赛115"></a>双周赛115</h2><p>leetcode_2899. 上一个遍历的整数<br>leetcode_2900. 最长相邻不相等子序列 I<br>leetcode_2901. 最长相邻不相等子序列 II</p><p>第二和第三题，由于是求子序列的问题，那么首先可以想到dp的办法，问题解决起来不算困难，但是存在优化的方法。那就是记录答案时考虑只记录下标，最后需要返回答案的时候遍历一次数组，直接返回，这样可以大大减少对List的操作，从而减少时间上的开销。然后就是算法的实现方面，也基本没什么问题，从后向前去找最大的满足要求的值就可以了。给出第三题未优化的版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getWordsInLongestSubsequence</span><span class="params">(<span class="type">int</span> n, String[] words, <span class="type">int</span>[] groups)</span> &#123;</span><br><span class="line">       <span class="comment">//子序列问题，应该想到dp求解，考虑右侧端点位置的元素</span></span><br><span class="line">       <span class="comment">//以右侧端点结尾的子序列的最长序列</span></span><br><span class="line">       List&lt;List&lt;String&gt;&gt; dp_list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxlen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       List&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       s.add(words[<span class="number">0</span>]);</span><br><span class="line">       dp_list.add(<span class="number">0</span>, s);</span><br><span class="line"></span><br><span class="line">       List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(s);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">           List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">               <span class="comment">//遍历子序列</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">Mlen</span> <span class="operator">=</span> temp.size();</span><br><span class="line">               <span class="keyword">if</span> (groups[j] != groups[i] &amp;&amp; words[j].length() == words[i].length() &amp;&amp; hammingDistance(words[i], words[j])) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (dp_list.get(j).size() &gt; Mlen) &#123;<span class="comment">//找到符合条件中的最大值</span></span><br><span class="line">                       temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(dp_list.get(j));</span><br><span class="line">                       Mlen = temp.size();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           temp.add(words[i]);</span><br><span class="line">           dp_list.add(temp);</span><br><span class="line">           <span class="keyword">if</span> (dp_list.get(i).size() &gt; maxlen) &#123;<span class="comment">//记录答案</span></span><br><span class="line">               maxlen = dp_list.get(i).size();</span><br><span class="line">               ans = dp_list.get(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hammingDistance</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length();</span><br><span class="line">       <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (a.charAt(i) != b.charAt(i)) &#123;</span><br><span class="line">               flag++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> flag == <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;双周赛115&quot;&gt;&lt;a href=&quot;#双周赛115&quot; class=&quot;headerlink&quot; title=&quot;双周赛115&quot;&gt;&lt;/a&gt;双周赛115&lt;/h2&gt;&lt;p&gt;leetcode_2899. 上一个遍历的整数&lt;br&gt;leetcode_2900. 最长相邻不相等子序列 I</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>字典树</title>
    <link href="https://xu-jia-wang.github.io/Learning-Records/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>https://xu-jia-wang.github.io/Learning-Records/%E5%AD%97%E5%85%B8%E6%A0%91/</id>
    <published>2023-10-19T02:19:59.000Z</published>
    <updated>2023-10-19T02:20:47.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前缀树Trie-字典树"><a href="#前缀树Trie-字典树" class="headerlink" title="前缀树Trie(字典树)"></a>前缀树Trie(字典树)</h2><p>Trie树的意义：<br> Trie树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串&#x2F;字符前缀」是否存在的数据结构。<br> 其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符是什么」。这样来形成一个树的形状，可以快速判断某个字符是否在树中(或者是否包含这个字符的前缀)<br> <img src="/Learning-Records/image-1.png" alt="Trie"></p><h3 id="Trie树的构建：使用二维数组或者使用TrieNode"><a href="#Trie树的构建：使用二维数组或者使用TrieNode" class="headerlink" title="Trie树的构建：使用二维数组或者使用TrieNode"></a>Trie树的构建：使用二维数组或者使用TrieNode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">100009</span>; <span class="comment">// 直接设置为十万级</span></span><br><span class="line">    <span class="type">int</span>[][] trie;</span><br><span class="line">    <span class="type">int</span>[] count;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        trie = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">26</span>];</span><br><span class="line">        count = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (trie[p][u] == <span class="number">0</span>) trie[p][u] = ++index;</span><br><span class="line">            p = trie[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">        count[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (trie[p][u] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = trie[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count[p] != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (trie[p][u] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = trie[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用TrieNode:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> end;</span><br><span class="line">        TrieNode[] tns = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrieNode root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.tns[u] == <span class="literal">null</span>) p.tns[u] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            p = p.tns[u]; </span><br><span class="line">        &#125;</span><br><span class="line">        p.end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.tns[u] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p.tns[u]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.tns[u] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p.tns[u]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode-648-单词替换"><a href="#leetcode-648-单词替换" class="headerlink" title="leetcode_648. 单词替换"></a>leetcode_648. 单词替换</h3><p>使用前缀树查找字符是否存在前缀，如果存在返回前缀，不存在直接返回字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">       <span class="type">boolean</span> end;</span><br><span class="line">       TrieNode[] tns = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   TrieNode root=<span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span> (p.tns[u] == <span class="literal">null</span>) p.tns[u] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">           p = p.tns[u];</span><br><span class="line">       &#125;</span><br><span class="line">       p.end = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    String  <span class="title function_">search</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span> (p.tns[u] == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">if</span> (p.tns[u].end) <span class="keyword">return</span> s.substring(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">           p = p.tns[u];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> s;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">replaceWords</span><span class="params">(List&lt;String&gt; dictionary, String sentence)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(String str:dictionary) insert(str);</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       String[] s = sentence.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (String x : s) &#123;</span><br><span class="line">          ans.append(search(x)).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans.toString().trim();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前缀树Trie-字典树&quot;&gt;&lt;a href=&quot;#前缀树Trie-字典树&quot; class=&quot;headerlink&quot; title=&quot;前缀树Trie(字典树)&quot;&gt;&lt;/a&gt;前缀树Trie(字典树)&lt;/h2&gt;&lt;p&gt;Trie树的意义：&lt;br&gt; Trie树（又叫「前缀树」或「字典树</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>周赛_367</title>
    <link href="https://xu-jia-wang.github.io/Learning-Records/%E5%91%A8%E8%B5%9B-367/"/>
    <id>https://xu-jia-wang.github.io/Learning-Records/%E5%91%A8%E8%B5%9B-367/</id>
    <published>2023-10-18T08:17:35.000Z</published>
    <updated>2023-10-18T08:19:10.916Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容为一个滑动窗口类问题+一个遍历记录最值问题。需要注意的地方就是记录最值之类的问题的思想。再碰到这类的问题应当想到这个</p><h3 id="leetcode-2904-最短且字典序最小的美丽子字符串"><a href="#leetcode-2904-最短且字典序最小的美丽子字符串" class="headerlink" title="leetcode_2904. 最短且字典序最小的美丽子字符串"></a>leetcode_2904. 最短且字典序最小的美丽子字符串</h3><p>2023年10月18日下午2点37分<br>题目要求找到最短的美丽子字符串，其次还要求字典序最小，应该找到符合的子串后比较字典序。碰到这样的子串类问题，考虑使用同向双指针的方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  String <span class="title function_">shortestBeautifulSubstring</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=s.length();</span><br><span class="line">    String ans=<span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>;<span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minlen=Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span> (right&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars[right]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">0</span>) &#123;</span><br><span class="line">                left = right;<span class="comment">//第一个1处</span></span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;<span class="comment">//计数器增1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;k)&#123;</span><br><span class="line">            <span class="comment">//窗口左移,到下一个1处</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">while</span> (chars[left]==<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==k)&#123;<span class="comment">//判断窗口内的元素是否是最短的</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> s.substring(left, right+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>((ans==<span class="literal">null</span>)||minlen&gt;substring.length()||((minlen==substring.length())&amp;&amp;judgingTheDictionaryOrder(ans,substring))) &#123;</span><br><span class="line">                ans= substring;</span><br><span class="line">                minlen=substring.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans==<span class="literal">null</span>?<span class="string">&quot;&quot;</span>:ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">judgingTheDictionaryOrder</span><span class="params">(String a,String b)</span>&#123;</span><br><span class="line">    <span class="comment">//比较a与b的字典序，如果b的字典序更小则返回true</span></span><br><span class="line">    <span class="type">int</span> n=a.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.charAt(i)&gt;b.charAt(i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.charAt(i)&lt;b.charAt(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode-2905-找出满足差值条件的下标-II"><a href="#leetcode-2905-找出满足差值条件的下标-II" class="headerlink" title="leetcode_2905. 找出满足差值条件的下标 II"></a>leetcode_2905. 找出满足差值条件的下标 II</h3><p>和之前的leetcode_2874. 有序三元组中的最大值 II是很相似的类型，同样是需要在O(N)的时间复杂度内找到满足条件的值，但是遍历一次就要找到，那么想到使用记录数来记录最大最小值，从而满足需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findIndices(<span class="type">int</span>[] nums, <span class="type">int</span> indexDifference, <span class="type">int</span> valueDifference) &#123;</span><br><span class="line">    <span class="type">int</span> n=nums.length;</span><br><span class="line">    <span class="type">int</span> maxInd=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minInd=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=indexDifference;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="type">int</span> i=j-indexDifference;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;nums[maxInd])&#123;</span><br><span class="line">            maxInd=i;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;nums[minInd])&#123;</span><br><span class="line">            minInd=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[maxInd]-nums[j]&gt;=valueDifference)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;maxInd,j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]-nums[minInd]&gt;=valueDifference)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;minInd,j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要内容为一个滑动窗口类问题+一个遍历记录最值问题。需要注意的地方就是记录最值之类的问题的思想。再碰到这类的问题应当想到这个&lt;/p&gt;
&lt;h3 id=&quot;leetcode-2904-最短且字典序最小的美丽子字符串&quot;&gt;&lt;a href=&quot;#leetcode-2904-最短且字典序最</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Markdown</title>
    <link href="https://xu-jia-wang.github.io/Learning-Records/Markdown/"/>
    <id>https://xu-jia-wang.github.io/Learning-Records/Markdown/</id>
    <published>2023-10-08T03:00:33.000Z</published>
    <updated>2023-10-19T02:20:50.065Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode-826-安排工作以达到最大收益"><a href="#leetcode-826-安排工作以达到最大收益" class="headerlink" title="leetcode_826. 安排工作以达到最大收益"></a>leetcode_826. 安排工作以达到最大收益</h3><p>贪心法：目标是最大利润，但是利润的获取是要建立在难度的许可之下的，所以首先对难度和工人能力排序，对于每个工人记录下他的能力下所能取得的最大利润，对于后面的工人，那么就需要判断他的能力能否突破上一个人的上限获取到更大的利润，使用一个数来记录最大利润就行。需要注意的是在进行while循环的时候注意j可能会超出数组范围，需要加入限制条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfitAssignment</span><span class="params">(<span class="type">int</span>[] difficulty, <span class="type">int</span>[] profit, <span class="type">int</span>[] worker)</span> &#123;</span><br><span class="line">      <span class="type">int</span> premaxprofit=Integer.MIN_VALUE;</span><br><span class="line">      <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> n= difficulty.length;</span><br><span class="line">      Arrays.sort(worker);<span class="comment">//先对工人排序</span></span><br><span class="line">      <span class="type">int</span>[][] d=<span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">          d[i][<span class="number">0</span>]=difficulty[i];</span><br><span class="line">          d[i][<span class="number">1</span>]=profit[i];</span><br><span class="line">      &#125;</span><br><span class="line">      Arrays.sort(d,(o1, o2) -&gt; o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);<span class="comment">//按照难度排序</span></span><br><span class="line">      <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; worker.length;i++) &#123;</span><br><span class="line">          <span class="keyword">while</span> (j&lt;n&amp;&amp;worker[i]&gt;=d[j][<span class="number">0</span>])&#123;</span><br><span class="line">              premaxprofit=Math.max(premaxprofit,d[j++][<span class="number">1</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">          ans+=(premaxprofit==Integer.MIN_VALUE?<span class="number">0</span>:premaxprofit);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode-8028-执行操作使两个字符串相等"><a href="#leetcode-8028-执行操作使两个字符串相等" class="headerlink" title="leetcode_8028. 执行操作使两个字符串相等"></a>leetcode_8028. 执行操作使两个字符串相等</h3><p>首先最常用的贪心是错误的，贪心是做不出这题的。采用dp的办法。那么既然考虑dp那么可以从开头也可以从结尾开始考虑情况。从结尾字符开始考虑。首先存在两种操作，分别记为op1和op2.</p><p>如果当前字符不相等采用op1：那么接下来的字符就可以免费翻转一次，代价+x<br>如果当前字符不等采用op2：那么下一个字符就需要被翻转，代价+1</p><p>所以需要记录免费翻转次数j,上一个字符是否采用了op2:PreRev</p><p>由于存在PreRev所以判断两个字符相等也变得复杂不再是简单的<code>s1[i]==s2[i]</code>,而是变成了<code>（s1[1]==s2[i]）==(PreRev==0)</code>,存在情况：两个字符本来不相等，但是当前这个需要翻转而出现相等的情况。</p><p>到这里dp所需要的元素都很明了：PreRev,j,i 也就是一个三维的数组，数组中存放的则是最小代价。</p><p>对于s1[i]!&#x3D;s2[i]:分成两种：采用op1以及op2:分别为dfs(i-1,j+1,0)+x,dfs(i-1,j,1)+1,同时j&gt;0的情况dfs(i-1,j-1,0),取这三者的最小值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(String s1, String s2, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">//采用dp的方法进行计算</span></span><br><span class="line">    <span class="type">int</span> n=s1.length();</span><br><span class="line">    <span class="type">char</span>[] s = s1.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] t = s2.toCharArray();</span><br><span class="line">    <span class="type">int</span> diff=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != t[i]) &#123;</span><br><span class="line">            diff ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(diff&gt;<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n][n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            Arrays.fill(dp[i][j], -<span class="number">1</span>);<span class="comment">// -1 表示没有计算过</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(s,t,x,n-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,dp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[] s, <span class="type">char</span>[] t, <span class="type">int</span> x, <span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> PreRev,<span class="type">int</span>[][][] dp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;<span class="comment">//递归边界</span></span><br><span class="line">        <span class="keyword">return</span> j&gt;<span class="number">0</span>|| PreRev&gt;<span class="number">0</span>?Integer.MAX_VALUE/<span class="number">2</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[i][j][PreRev]!=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//之前计算过这个值</span></span><br><span class="line">        <span class="keyword">return</span> dp[i][j][PreRev];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[i]==t[i]&amp;&amp;PreRev==<span class="number">0</span>)&#123;<span class="comment">//当前字符不需要翻转</span></span><br><span class="line">        <span class="keyword">return</span> dfs(s,t,x,i-<span class="number">1</span>,j,<span class="number">0</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=Math.min(dfs(s,t,x,i-<span class="number">1</span>,j+<span class="number">1</span>,<span class="number">0</span>,dp)+x,dfs(s,t,x,i-<span class="number">1</span>,j,<span class="number">1</span>,dp)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        res=Math.min(res,dfs(s,t,x,i-<span class="number">1</span>,j-<span class="number">1</span>,<span class="number">0</span>,dp));</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][j][PreRev]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode-576-出界的路径数"><a href="#leetcode-576-出界的路径数" class="headerlink" title="leetcode_576. 出界的路径数"></a>leetcode_576. 出界的路径数</h3><p>考虑使用动态规划解决问题。<br>首先，存在三个变量：i,j,k 分别代表行、列、移动次数，考虑使用三重dp,遍历移动次数，每次移动次数都需要遍历棋盘，找到可以到达的位置。分析这个位置可能出现情况：<br>    可到达的位置不出界，那么当前位置路径数&#x3D;上一个位置路径数+当前位置路径数<br>    可到达的位置出界，那么直接记录一下出界的路径数&#x3D;出界的路径数+上一个位置路径数<br>最后答案就是出界路径数的值.</p><p>需要注意的是要设定初始出发位置的值应该为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> maxMove, <span class="type">int</span> startRow, <span class="type">int</span> startColumn)</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> MOD=<span class="number">1000000007</span>;</span><br><span class="line">      <span class="type">int</span>[][][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m][n][maxMove+<span class="number">1</span>];</span><br><span class="line">      <span class="type">int</span>[][] d=<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">      dp[startRow][startColumn][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//初始位置，路径数为1 </span></span><br><span class="line">      <span class="type">int</span> out=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;maxMove;k++)&#123;<span class="comment">//三维dp，每次都是找当前步数下可以到达的位置，坐标全部遍历是为了防止漏掉当前层的可到达位置</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                  <span class="type">int</span> count=dp[i][j][k];<span class="comment">//路径数</span></span><br><span class="line">                  <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                      <span class="keyword">for</span>(<span class="type">int</span>[] dirs:d)&#123;</span><br><span class="line">                          <span class="type">int</span> i1=i+dirs[<span class="number">0</span>];</span><br><span class="line">                          <span class="type">int</span> j1=j+dirs[<span class="number">1</span>];</span><br><span class="line">                          <span class="keyword">if</span>(i1&gt;=<span class="number">0</span>&amp;&amp;i1&lt;m&amp;&amp;j1&gt;=<span class="number">0</span>&amp;&amp;j1&lt;n)&#123;</span><br><span class="line">                              <span class="comment">//移动之后在界内，更新移动后位置的路径数</span></span><br><span class="line">                              dp[i1][j1][k+<span class="number">1</span>]=(count+dp[i1][j1][k+<span class="number">1</span>])%MOD;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">else</span> &#123;<span class="comment">//移动之后在界外，那么就需要将上一个位置所在的路径数全部加到出界数上</span></span><br><span class="line">                              out=(count+out)%MOD;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> out;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode-1186-删除一次得到子数组最大和"><a href="#leetcode-1186-删除一次得到子数组最大和" class="headerlink" title="leetcode_1186. 删除一次得到子数组最大和"></a>leetcode_1186. 删除一次得到子数组最大和</h3><p>子数组之类的问题：统统是枚举右侧端点，当前这个位置为子序列的右侧端点时的情况：分类讨论，如果不需要删除那么就都是一样的，当必须要删除一个节点时那么首先考虑删除当前节点，或者之前删除过当前不删。一共三类情况，使用dfs的记忆化搜索可能更加便于理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] num;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[][] dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maximumSum</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">//枚举右端点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">    num = arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Arrays.fill(dp[i], Integer.MIN_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        ans = Math.max(ans, Math.max(dfs(i, <span class="number">0</span>), dfs(i, <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> Integer.MIN_VALUE / <span class="number">2</span>;<span class="comment">//边界</span></span><br><span class="line">    <span class="keyword">if</span> (dp[i][j] != Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j] = Math.max(dfs(i - <span class="number">1</span>, <span class="number">0</span>),<span class="number">0</span>) + num[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> dp[i][j] = Math.max(dfs(i - <span class="number">1</span>, <span class="number">0</span>), dfs(i - <span class="number">1</span>, <span class="number">1</span>) + num[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode-918-环形子数组的最大和"><a href="#leetcode-918-环形子数组的最大和" class="headerlink" title="leetcode_918. 环形子数组的最大和"></a>leetcode_918. 环形子数组的最大和</h3><p>环形子数组，可能解决起来很困难。但是反向考虑，正向求解困难那么就反向求解，求出子数组之和的最小值，那么sums-最小值得到的就是横跨边界的子数组的最大值。同样求出不横跨边界的最大值，取两者之间的最大值即可。但是要注意的是子数组最小有可能是整个数组，如果是整个数组那么此时的答案就应该是直接返回不横跨边界的最大值（这种情况sums-最小值&#x3D;&#x3D;0,且max不一定就比0大，可能最后的答案错误为空）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maximumSubstring</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minimumSubstring</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span>[] dp1 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] dp2 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sums</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp1[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp2[<span class="number">0</span>] =  nums[<span class="number">0</span>];</span><br><span class="line">        maximumSubstring = Math.max(dp1[<span class="number">0</span>], maximumSubstring);</span><br><span class="line">        minimumSubstring = Math.min(minimumSubstring, dp2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp1[i] = Math.max(dp1[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            dp2[i] = Math.min(dp2[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            maximumSubstring = Math.max(maximumSubstring, dp1[i]);</span><br><span class="line">            minimumSubstring = Math.min(minimumSubstring, dp2[i]);</span><br><span class="line">            sums += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sums == minimumSubstring) <span class="keyword">return</span> maximumSubstring;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maximumSubstring, sums - minimumSubstring);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode-1105-填充书架"><a href="#leetcode-1105-填充书架" class="headerlink" title="leetcode_1105. 填充书架"></a>leetcode_1105. 填充书架</h3><p>很明显题目需要使用动态规划的方式。</p><p>值得注意和思考的地方是，记忆化搜索考虑自后向前，自前向后则是递归，显然自后向前的方式更容易考虑</p><p>首先确定子问题是什么？动态规划类的子问题一般都是从后向前考虑，那么子问题显然可以考虑成和原问题相类似的问题：原问题：给定n本书，确定最小高度。子问题：确定最后一层能放的书（最后一本）之后考虑剩下的x本书的最小高度。（必定存在最后一层）。这里最后一本一定在最后一层，但是最后一层不一定只有最后一本，所以需要判断倒数第二本在最后一层或者不在的情况，取这些情况的最小值。<br>定义dfs为从0到i的最小高度<br>枚举最后一层的下标j,那么从j到i的最大高度就是最后一层的高度,而这个j究竟能取到多少不是一次就可以确定的，这需要计算：所以$dfs(i)&#x3D;min(dfs(j-1)+max_{k&#x3D;j}^i book[k][1]$);并且要满足每一层的宽度小于参数selfwidth,<br>那么在枚举最后一层的下标的时候就需要注意这一点，如果宽度超出直接break;<br>最后返回dfs(n-1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] dp;</span><br><span class="line">  <span class="type">int</span> width;</span><br><span class="line">  <span class="type">int</span>[][] book;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minHeightShelves</span><span class="params">(<span class="type">int</span>[][] books, <span class="type">int</span> shelfWidth)</span> &#123;</span><br><span class="line">      <span class="comment">//考虑dp进行划分子问题：</span></span><br><span class="line">      <span class="comment">// 存在子问题，当最后一层是确定的时候，剩下的书组成的最小高度问题是和原问题类似的问题，所以可以使用动态规划</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> books.length;</span><br><span class="line">      dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">      Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line">      width=shelfWidth;</span><br><span class="line">      book=books;</span><br><span class="line">     <span class="keyword">return</span> dfs(n-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">      <span class="comment">//定义递归的出口</span></span><br><span class="line">      <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//没有书了</span></span><br><span class="line">      <span class="keyword">if</span>(dp[i]!=-<span class="number">1</span>) <span class="keyword">return</span> dp[i];</span><br><span class="line">      <span class="type">int</span> leftw=width;<span class="type">int</span> maxH=<span class="number">0</span>;<span class="type">int</span> res=Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=<span class="number">0</span>;j--)&#123;<span class="comment">//j是这一层的最后一本书，j-1代表了前面的那本</span></span><br><span class="line">          leftw-=book[j][<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">if</span>(leftw&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          maxH=Math.max(book[j][<span class="number">1</span>],maxH);<span class="comment">//获取这一层可以放的书的最大高度</span></span><br><span class="line">          res=Math.min(dfs(j-<span class="number">1</span>)+maxH,res);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[i]=res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode-983-最低票价"><a href="#leetcode-983-最低票价" class="headerlink" title="leetcode_983. 最低票价"></a>leetcode_983. 最低票价</h3><p>记忆化搜索。<br>首先确定整个问题的子问题是什么？假设最后一天一定是需要买票的，那么就存在三种情况：买一天的、买七天的、买三十天的，那么我们只需要找到下一个需要买票的位置，再进行记忆化搜索。最后取这些数的最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] dp;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mincostTickets</span><span class="params">(<span class="type">int</span>[] days, <span class="type">int</span>[] costs)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> days.length;</span><br><span class="line">       dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">       Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> dfs(n - <span class="number">1</span>, days, costs);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] days, <span class="type">int</span>[] costs)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (dp[i] != -<span class="number">1</span>) <span class="keyword">return</span> dp[i];</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>, k = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i; m &gt;= <span class="number">0</span>; --m) &#123;</span><br><span class="line">           <span class="keyword">if</span> (days[i] - days[m] &gt; <span class="number">6</span>) &#123;<span class="comment">//这个节点需要重新买票</span></span><br><span class="line">               j = m;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i; m &gt;= <span class="number">0</span>; --m) &#123;</span><br><span class="line">           <span class="keyword">if</span> (days[i] - days[m] &gt; <span class="number">29</span>) &#123;</span><br><span class="line">               k = m;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       dp[i] = Math.min(dfs(i - <span class="number">1</span>, days, costs) + costs[<span class="number">0</span>], Math.min(dfs(j, days, costs) + costs[<span class="number">1</span>], dfs(k, days, costs) + costs[<span class="number">2</span>]));<span class="comment">//上一个买票的点处，如果超出范围那么直接就是</span></span><br><span class="line">       <span class="keyword">return</span> dp[i];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode-646-最长数对链"><a href="#leetcode-646-最长数对链" class="headerlink" title="leetcode_646. 最长数对链"></a>leetcode_646. 最长数对链</h3><p>这题首先想到的就是对数组首先需要排序，排序应该按照右侧排序(右侧相同，按照左侧进行升序)，排序完成后就选择添加就行了。贪心：每次添加的都是最小的，这样到最后添加的数目应该就是最大的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findLongestChain</span><span class="params">(<span class="type">int</span>[][] pairs)</span> &#123;</span><br><span class="line">    <span class="comment">//考虑使用贪心</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pairs.length;</span><br><span class="line">    Arrays.sort(pairs, (o1, o2) -&gt; o1[<span class="number">1</span>] == o2[<span class="number">1</span>] ? o1[<span class="number">0</span>] - o2[<span class="number">0</span>] : o1[<span class="number">1</span>] - o2[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pairs[right][<span class="number">0</span>] &gt; pairs[left][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">//增加链长</span></span><br><span class="line">            left = right;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125; </span><br><span class="line">            right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;leetcode-826-安排工作以达到最大收益&quot;&gt;&lt;a href=&quot;#leetcode-826-安排工作以达到最大收益&quot; class=&quot;headerlink&quot; title=&quot;leetcode_826. 安排工作以达到最大收益&quot;&gt;&lt;/a&gt;leetcode_826.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://xu-jia-wang.github.io/Learning-Records/hello-world/"/>
    <id>https://xu-jia-wang.github.io/Learning-Records/hello-world/</id>
    <published>2023-10-08T01:29:28.433Z</published>
    <updated>2023-10-08T01:29:28.435Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
